--Tejas Kulkarni (tejask@mit.edu | tejasdkulkarni@gmail.com)
-- Unsupervised Face Synthesis (Conv encoder + decoder)
-- Usage: OMP_NUM_THREADS=1 th main.lua -t 1 -s log 
--so far: th main.lua -t 1 -s log_l20.0001 -p --coefL2 0.0001

--OMP_NUM_THREADS=1 th main.lua -t 1 -r 0.01 --coefL2 0.001 -f 1 -d ../../PASCAL3D/combined/ -p

require 'cunn'
require 'pl'
require 'paths'
require 'optim'
require 'gnuplot'
require 'math'
require 'rmsprop'
require 'cudnn'
require 'nnx'
require("UnPooling.lua")
require 'image'
require('LinearCR')
require('Reparametrize')
require('GaussianCriterion')
----------------------------------------------------------------------
-- parse command-line options
--
local opt = lapp[[
   -s,--save          (default "logs")      subdirectory to save logs
   -n,--network       (default "")          reload pretrained network
   -m,--model         (default "convnet")   type of model tor train: convnet | mlp | linear
   -p,--plot                                plot while training
   -o,--optimization  (default "SGD")       optimization: SGD | LBFGS 
   -r,--learningRate  (default 0.05)        learning rate, for SGD only
   -m,--momentum      (default 0)           momentum, for SGD only
   -i,--maxIter       (default 3)           maximum nb of iterations per batch, for LBFGS
   --coefL1           (default 0)           L1 penalty on the weights
   --coefL2           (default 0)           L2 penalty on the weights
   -t,--threads       (default 4)           number of threads
   --dumpTest                                preloads model and dumps .mat for test
   -d,--datasrc       (default "")          data source directory
   -f,--fbmat         (default 0)           load fb.mattorch       
]]

if opt.fbmat == 1 then
  mattorch = require('fb.mattorch')
else
  require 'mattorch'
end

-- threads
torch.setnumthreads(opt.threads)
print('<torch> set nb of threads to ' .. torch.getnumthreads())

-- use floats, for SGD
if opt.optimization == 'SGD' then
   torch.setdefaulttensortype('torch.FloatTensor')
end

-- batch size?
if opt.optimization == 'LBFGS' and opt.bsize < 100 then
   error('LBFGS should not be used with small mini-batches; 1000 is a recommended')
end


bsize = 50
imwidth = 150

TOTALFACES = 1000--5230
num_train_batches = 950--5000
num_test_batches =  TOTALFACES-num_train_batches

function load_batch(id, mode)
  return torch.load('DATASET/th_' .. mode .. '/batch' .. id)
end

function init_network()
 -- Model Specific parameters
  filter_size = 5
  dim_hidden = 30*2
  input_size = 32*2
  pad1 = 2
  pad2 = 2
  colorchannels = 1
  total_output_size = colorchannels * input_size ^ 2
  feature_maps = 16*2
  hidden_dec = 25*2
  map_size = 16*2
  factor = 2
  encoder = nn.Sequential()
  encoder:add(nn.SpatialZeroPadding(pad1,pad2,pad1,pad2))
  encoder:add(nn.SpatialConvolutionMM(colorchannels,feature_maps,filter_size,filter_size))
  encoder:add(nn.SpatialMaxPooling(2,2,2,2))
  encoder:add(nn.Threshold(0,1e-6))
  encoder:add(nn.Reshape(feature_maps * map_size * map_size))
  local z = nn.ConcatTable()
  z:add(nn.LinearCR(feature_maps * map_size * map_size, dim_hidden))
  z:add(nn.LinearCR(feature_maps * map_size * map_size, dim_hidden))
  encoder:add(z)
  local decoder = nn.Sequential()
  decoder:add(nn.LinearCR(dim_hidden, feature_maps * map_size * map_size))
  decoder:add(nn.Threshold(0,1e-6))
  --Reshape and transpose in order to upscale
  decoder:add(nn.Reshape(bsize, feature_maps, map_size, map_size))
  decoder:add(nn.Transpose({2,3},{3,4}))
  --Reshape and compute upscale with hidden dimensions
  decoder:add(nn.Reshape(map_size * map_size * bsize, feature_maps))
  decoder:add(nn.LinearCR(feature_maps,hidden_dec))
  decoder:add(nn.Threshold(0,1e-6))
  decoder:add(nn.LinearCR(hidden_dec,colorchannels*factor*factor))
  decoder:add(nn.Sigmoid())
  decoder:add(nn.Reshape(bsize,1,input_size,input_size))

  model = nn.Sequential()
  model:add(encoder)
  model:add(nn.Reparametrize(dim_hidden))
  model:add(decoder)
    
  model:cuda()  
  collectgarbage()
  return model
end



function test_fw_back(model)
  res=model:forward(load_batch(1,'training'):cuda())
  print(res:size())
--  rev=model:backward(training['X'][1]:cuda(),  training['Y'][1]:cuda())
--  print(rev:size())
end

model = init_network()
-- test_fw_back(model)
-- print(model)

parameters,gradParameters = model:getParameters()

criterion = nn.MSECriterion():float()
-- criterion = nn.GaussianCriterion():float()

-- log results to files
trainLogger = optim.Logger(paths.concat(opt.save, 'train.log'))
testLogger = optim.Logger(paths.concat(opt.save, 'test.log'))
reconstruction = 0

--module IDs
rmsGradAverages = {}
LCRnodes, containers = model:findModules('nn.LinearCR')
convnodes, containers = model:findModules('nn.SpatialConvolutionMM')

for i=1, #LCRnodes do
  rmsGradAverages[i]={}
  rmsGradAverages[i].module = LCRnodes[i]
  rmsGradAverages[i].W = 1
  rmsGradAverages[i].b = 1
  rmsGradAverages[i].config = {
    learningRate = -0.001,
    momentumDecay = 0.1,
    updateDecay = 0.01
    }
end

for i= #LCRnodes+1, #LCRnodes+#convnodes do
  rmsGradAverages[i]={}
  rmsGradAverages[i].module = convnodes[i-#LCRnodes]
  rmsGradAverages[i].W = 1
  rmsGradAverages[i].b = 1
  rmsGradAverages[i].config = {
    learningRate = -0.001,
    momentumDecay = 0.1,
    updateDecay = 0.01
    }
end

-- learning_rate = opt.learningRate

RMSProp = true

--training function
function train()
   -- epoch tracker
   epoch = epoch or 1

   -- local vars
   local time = sys.clock()

   -- if math.fmod(epoch+1, 50) == 0 then
   --  opt.learningRate = opt.learningRate*0.5
   -- end
   reconstruction = 0
   -- do one epoch
   print('<trainer> on training set:')
   print("<trainer> online epoch # " .. epoch .. ' [bsize = ' .. bsize .. ']')
   bseq = torch.randperm(num_train_batches)
   for tt = 1,num_train_batches do
      t = bseq[tt]
      -- create mini batch
      local raw_inputs = load_batch(t, 'training')
      local targets = raw_inputs
      
      inputs = raw_inputs:cuda()

      -- optimize on current mini-batch
      
      if RMSProp then
        gradParameters:zero()
        -- evaluate function for complete mini batch
        local outputs = model:forward(inputs)
        outputs = outputs:float()
        local f = criterion:forward(outputs, targets)
        
        reconstruction = reconstruction + f

        -- estimate df/dW
        local df_do = criterion:backward(outputs, targets)
        model:backward(inputs, df_do:cuda())

        -- Stochastic RMSProp on separate layers

        for ii =1, #rmsGradAverages do
          rmsGradAverages[ii].module.weight = rmsprop(rmsGradAverages[ii].module.weight, rmsGradAverages[ii].module.gradWeight, rmsGradAverages[ii].config, rmsGradAverages[ii].W)
          rmsGradAverages[ii].module.bias = rmsprop(rmsGradAverages[ii].module.bias, rmsGradAverages[ii].module.gradBias, rmsGradAverages[ii].config, rmsGradAverages[ii].b)
        end
      else

        local outputs = model:forward(inputs)
        outputs = outputs:float()
        -- feed it to the neural network and the criterion
        local f = criterion:forward(outputs, targets)
        reconstruction = reconstruction + f
        -- (1) zero the accumulation of the gradients
        model:zeroGradParameters()
        -- (2) accumulate gradients
        local df_do = criterion:backward(outputs, targets)
        model:backward(inputs, df_do:cuda())
        -- (3) update parameters with a 0.01 learning rate
        model:updateParameters(learning_rate)

      end
      -- disp progress
      xlua.progress(t, num_train_batches)
   end
   
   -- time taken
   time = sys.clock() - time
   time = time / num_train_batches
   print("<trainer> time to learn 1 sample = " .. (time*1000) .. 'ms')

   -- print confusion matrix
   reconstruction = reconstruction / ((num_train_batches))
   print('mean MSE (train set):', reconstruction)
   trainLogger:add{['% mean MSE (train set)'] = reconstruction}
   reconstruction=0

   -- save/log current net
   if math.fmod(epoch, 5) ==0 then
     local filename = paths.concat(opt.save, 'vxnet.net')
     os.execute('mkdir -p ' .. sys.dirname(filename))
     if paths.filep(filename) then
        os.execute('mv ' .. filename .. ' ' .. filename .. '.old')
     end
     print('<trainer> saving network to '..filename)
     torch.save(filename, model)
   end
   
   -- next epoch
   epoch = epoch + 1
end



-- test function
function testf()
   -- local vars
   local time = sys.clock()

   -- test over given dataset
   print('<trainer> on testing Set:')

   reconstruction = 0

   for t = 1,num_test_batches do
      -- create mini batch
      local raw_inputs = load_batch(t, 'test')
      local targets = raw_inputs

      inputs = raw_inputs:cuda()
      -- disp progress
      xlua.progress(t, num_test_batches)

      -- test samples
      local preds = model:forward(inputs)
      preds = preds:float()

      reconstruction = reconstruction + torch.sum(torch.pow(preds-targets,2))
      
      if t == 1 then
        torch.save('tmp/preds', preds)
      end
   end


   -- timing
   time = sys.clock() - time
   time = time / num_test_batches
   print("<trainer> time to test 1 sample = " .. (time*1000) .. 'ms')

   -- print confusion matrix
   reconstruction = reconstruction / (bsize * num_test_batches * 3 * 150 * 150)
   print('mean MSE error (test set)', reconstruction)
   testLogger:add{['% mean class accuracy (test set)'] = reconstruction}
   reconstruction = 0
end


----------------------------------------------------------------------
-- and train!
--

tcounter = 0
while true do
   -- train/test
  train()
  if math.fmod(tcounter,3) == 0 then
    testf()
  end
  tcounter = tcounter + 1

 -- plot errors
 if opt.plot then
    trainLogger:style{['% mean class accuracy (train set)'] = '-'}
    testLogger:style{['% mean class accuracy (test set)'] = '-'}
    trainLogger:plot()
    testLogger:plot()
 end
end
--]]
